# 백준 2565 전깃줄

## 제거해야할 전깃줄의 갯수

제거해야할 전깃줄의 갯수를 파악하는 것은 힘들다. 따라서 '전체 전깃줄 수' - '설치 가능한 전깃줄 수' 를 해주어야한다.

## 설치 가능한 전깃줄 수

이 문제를 풀기 위해서는 전깃줄이 꼬여있는 지 확인할 수 있어야 한다.<br>
전깃줄이 꼬여있는 상태가 아니여야 설치 가능한 전깃줄이다. 그렇다면 전깃줄이 꼬였는 지 아닌 지를 확인하는 방법은 무엇일까?<br>
A를 기준으로 정렬하였을 때 B의 수들이 증가하는 형태가 되어야 설치 가능한 전깃줄이라는 것이다.<br>
A: 1 2 3 4 6 7 9 10<br>
B: 8 2 9 1 4 6 7 10<br>
이 상태에서 (1,8),(2,2),(3,9)같은 경우 증가하는 형태가 아니기 때문에 전깃줄을 설치할 수 없다.<br>

즉 설치 가능한 전깃줄 수를 찾기 위해서는 A를 기준으로 정렬한 후 B의 최장 증가 수열(Longest Increasing Sequence)를 구해야한다.

## A를 기준으로 정렬하기 

2차원 배열을 정렬하는 함수는 없기 때문에 compare메소드를 오버라이딩하여 정렬한다. <br>
여기서 알게 된 점은 int[]형 배열을 사용할 경우 T는 int가 된다는 점이다.<br>
이 문제에서는 2차원 배열을 정렬해야 하기 때문에 T는 int[]가 된다.
<pre>
<code>
Arrays.sort(wire,new Comparator<int[]>(){
			@Override
			public int compare(int []o1,int[]o2) {
				return o1[0]-o2[0];
			}
		});
</code>
</pre>
참고:11650 좌표 구하기

## LIS 구하기
11053번을 참고하여 가장 긴 증가하는 수열을 찾았다.<br>
참고:11053 가장 긴 증가하는 수열

    
