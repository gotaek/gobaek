# 백준 2981 검문

단순한 브루트 포스법으로 이 문제를 해결하려 하였지만 시간이 너무 많이 걸려 다른 해결방법을 생각해내야 했다.<br>
결국 해결방법을 찾지 못하고 여러 블로그를 오랜 시간동안 참고한 후 겨우겨우 이해할 수 있었다.

## 해결방법

1.배열의 차이들을 구하기<br>
2.차이들의 최대 공약수 구하기<br>
3.최대 공약수의 약수들을 구하기

## 1.배열의 차이들을 구하기 

입력을 받는 배열을 v[]라고 하고 정답을 m이라고 하자. 그럼 다음과 같은 식이 성립한다.<br>
v[1]%m=v[1]-m*(v[1]/m)<br>
v[2]%m=v[2]-m*(v[2]/m) ...

나머지가 같은 것들을 구해야 하므로 답을 구하기 위해서는 v[2]%m==v[1]%m이여야 한다.<br>
따라서 v[1]-m*(v[1]/m)==v[2]-m*(v[2]/m)이다. <br>
즉 v[2]-v[1]==m*(v[2]/m-v[1]/m)이며 v[i]-v[i-1]==m*(v[i]/m-v[i-1]/m)으로 모든 식에 성립한다.<br>
b=a*n에서 n은 약수이다. 위의 식도 m은 v[i]-v[i-1]의 약수를 의미한다.<br>
따라서 차이들의 최대공약수를 구한 후 그 최대공약수의 약수를 구하면 답이 나온다.

## 2.차이들의 최대 공약수 구하기

최대 공약수를 구하기 위해서 유클리드 알고리즘을 사용했다. 유클리드 함수는 다음과 같이 쓸 수 있다고 한다.
<pre>
<code>
public static int GCD(int a,int b) {
		if(a%b==0) return b;
		else return GCD(b,a%b);
	}
</code>
최대공약수를 구할 수 있는 방법인 유클리드 알고리즘을 잘 알아둬야겠다.
</pre>

## 3. 최대공약수의 약수 구하기 

단순하게 반복문을 사용하여서 약수를 구해줬다.
